# 알고리즘



## 알고리즘 최신 출제 경향

1. 구현
2. BFS/DFS
3. 그리디
4. 정렬
5. 다이나믹 프로그래밍
6. 이진 탐색
7. 최단 경로
8. 그래프 이론



## 복잡도



* 복잡도 : 알고리즘의 성능을 나타내는 척도
  * 시간 복잡도 : 특정한 크기의 입력에 대하여 알고리즘의 수행 시간 분석
  * 공간 복잡도 : 특정한 크기의 입력에 대하여 알고리즘의 메모리 사용량 분석
    * 복잡도가 낮을수록 좋은 알고리즘
* 빅오 표기법(Big-O Notation)
  * 가장 빠르게 증가하는 항만을 고려하는 표기법
  * ex) 3N^3 + 5N^2 + 1,000,000
  * 빅오 표기법에서는 차수가 가장 큰 항만 남기므로 O(N^3)으로 표현된다.
  * O(1) - 상수 시간 
  * O(logN) - 로그 시간
  * O(N) - 선형 시간
  * O(NlogN) - 로그 선형 시간
* 연산 횟수가 5억을 넘어가는 경우:
  * Python = 5 ~ 15초 가량의 시간이 소요
  * PyPy의 경우 때때로 C언어보다도 빠르게 동작
* 코딩 테스트 문제에서 시간제한은 통상 1 ~ 5초가량
* N의 범위가 500 = O(N^3)
* N의 범위가 2,000 = O(N^2)
* N의 범위가 100,000 = O(N logN)
* N의 범위가 10,000,000 = O(N)



## 알고리즘 문제 해결 과정



1. 지문 읽기 및 컴퓨터적 사고
2. 요구사항(복잡도) 분석
3. 문제 해결을 위한 아이디어 찾기
4. 소스코드 설계 및 코딩





## 파이썬 

* 리스트 컴프리헨션

```python
array = [i for i in range(1,11) if i % 2 ==1]

array = [[0] * m for _ in range(n)]


n = 4
m = 3
array = [[0] * m for _ in range(n)]
print(array)


```



* _(언더바) = 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 사용





### 튜플

#### 튜플을 사용하는 경우

1. 서로 다른 성질의 데이터를 묶어서 관리해야 할 때
2. 데이터의 나열을 해싱의 키 값으로 사용해야 할 때
3. 리스트보다 메모리를 효율적으로 사용해야 할 때



### 집합

1. 중복을 허용하지 않는다.
2. 순서가 없다.



#### 사전과 집합

1. 리스트나 튜플은 순서가 있기 때문에 인덱싱을 통해 자료형의 값을 얻을 수 있다.
2. 사전 자료형과 집합 자료형은 순서가 없기 때문에 인덱시으로 값을 얻을 수 없다.



### 내장함수



* itertools : 파이썬 반복되는 형태의 데이터를 처리하기 위한 유용한 기능들을 제공
  * 특히 순열과 조합 라이브러리는 코딩 테스트에서 자주 사용
* heapq : 힙 자료구조를 제공
  * 일반적으로 우선순위 큐 기능을 구현하기 위해 사용
* bisect : 이진 탐색 기능을 제공
* collections : 덱 , 카운터 등의 유용한 자료구조를 포함
* math : 필수적인 수학적 기능



* eval = 문자형을 정수로





## 순열 

* 서로 다른 n개에서 서로 다른 r개를 선택하여 일렬로 나열하는 것
* nPr



## 조합

* 서로 다른 n개에서 순서에 상관 없이 서로 다른 r개를 선택하는 것
* nCr



## 그리디

### 개요

* 현재 상황에서 지금 당장 좋은 것만 고르는 방법
* 최소한의 아이디어를 떠올릴 수 있는 능력을 요구
* 정당성 분석이 중요
* 시간 복잡도 O(N)